<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>4SP - DOOM</title>

  <!-- The core js-dos API -->
  <script type="text/javascript" src="js-dos-api.js"></script>
  
  <style>
    /* Make the game fill the entire browser viewport */
    html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden; /* No scrollbars */
        background: #000; /* Black background */
    }
    
    /* Container for the DOSBox instance */
    #DOOM {
        width: 100%;
        height: 100%;
        position: relative; /* For the overlay */
    }
    
    /* Ensure the js-dos canvas and container fill our #DOOM div */
    #DOOM > .dosbox-container,
    #DOOM canvas {
        width: 100% !important;
        height: 100% !important;
        margin: 0;
    }
    
    /* Styling for the loading overlay */
    #DOOM > .dosbox-container > .dosbox-overlay {
        background: url("DOOM.png"); /* Local splash screen */
        background-size: cover;
        background-position: center;
    }
    
    /* Hide the default js-dos start button, as we will click it with code */
    #DOOM .dosbox-start {
        display: none !important;
    }
  </style>
</head>

<body>
    <!-- The only element in the body is the game container -->
    <div id="DOOM" class="dosbox-default"></div>

  <script>
    // --- JS-DOS DOOM Initialization ---
    var dosbox_DOOM = new Dosbox({
        id: "DOOM",
        onload: function(dosbox) {
            // This runs after the user "clicks" play (which we do automatically)
            dosbox.run("DOOM-@evilution.zip", "./DOOM/DOOM.EXE");
        }
    });

    // --- SILENT STARTUP LOGIC ---
    // This logic prevents the loud static sound at the beginning
    // by muting the audio context before the game starts
    // and restoring it after a delay.
    
    const originalAudioContext = window.AudioContext || window.webkitAudioContext;
    let modifiedAudioContexts = [];

    /**
     * Intercepts AudioContext creation and routes it through a muted GainNode.
     */
    function engageSilentProcessing() {
        if (!originalAudioContext) {
            console.warn("Web Audio API not supported. Cannot apply silent processing.");
            return;
        }

        class SilentAudioContext extends originalAudioContext {
            constructor(options) {
                super(options);
                const masterGain = this.createGain();
                masterGain.gain.setValueAtTime(0, this.currentTime);
                masterGain.connect(super.destination);

                Object.defineProperty(this, 'destination', {
                    value: masterGain,
                    writable: false,
                });
                
                console.log("AudioContext created with silent gain node. Audio is processing but not audible.");
                modifiedAudioContexts.push(this);
            }
        }
        
        window.AudioContext = SilentAudioContext;
        window.webkitAudioContext = SilentAudioContext;
        console.log("Global AudioContext has been temporarily overwritten to enforce silent startup.");
    }

    /**
     * Restores the audio output and original browser functionality.
     */
    function restoreAudioOutput() {
        if (!originalAudioContext) return;

        modifiedAudioContexts.forEach(context => {
            if (context.destination && typeof context.destination.gain?.setValueAtTime === 'function') {
                context.destination.gain.setValueAtTime(1, context.currentTime);
                console.log("Restored volume for a modified AudioContext.");
            }
        });
        modifiedAudioContexts = [];

        window.AudioContext = originalAudioContext;
        window.webkitAudioContext = originalAudioContext;
        console.log("Global AudioContext has been restored.");
    }

    // --- Auto-start logic ---
    // This IIFE (Immediately Invoked Function Expression) runs right away.
    (function() {
        console.log("Attempting auto-start...");
        
        // 1. Engage silent processing BEFORE starting the game.
        console.log("Engaging silent processing for 15 seconds.");
        engageSilentProcessing();
        
        // 2. Find and click the original js-dos start button.
        // This button is created by the 'new Dosbox' call above.
        const originalStartBtn = document.querySelector('#DOOM .dosbox-start');
        
        if (originalStartBtn) {
            originalStartBtn.click();
            console.log("Auto-start click sent.");
        } else {
            console.error("Auto-start failed: .dosbox-start button not found immediately.");
            // Fallback: try again after a short delay, just in case.
            setTimeout(() => {
                const delayedStartBtn = document.querySelector('#DOOM .dosbox-start');
                if (delayedStartBtn) {
                    delayedStartBtn.click();
                    console.log("Delayed auto-start click sent.");
                } else {
                    console.error("Delayed auto-start also failed.");
                }
            }, 500); // 500ms delay
        }
        
        // 3. Set a timer to restore audio output after 15 seconds.
        setTimeout(() => {
            console.log("15 seconds have passed. Restoring audio output.");
            restoreAudioOutput();

            // As a fallback, also call the js-dos unmute function
            if (dosbox_DOOM && typeof dosbox_DOOM.unmute === 'function') {
                dosbox_DOOM.unmute();
            }
        }, 15000);
    })();
    // --- End Auto-start logic ---

  </script>
</body>
</html>
